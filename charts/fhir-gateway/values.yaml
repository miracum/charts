# Default values for fhir-gateway.
common:
  # -- metadata.annotations to apply to all deployments
  deploymentAnnotations: {}

# -- number of replicas. The application is well-suited to scale horizontally if required.
replicaCount: 1

# @ignored
image:
  registry: ghcr.io
  repository: miracum/fhir-gateway
  tag: v4.0.0@sha256:0b26a6e955ce7a1b69b33c936379dcaa036df60c6e8f97581dabe7b218b56553
  pullPolicy: IfNotPresent

# -- image pull secrets for the pod
imagePullSecrets: []

# -- String to partially override fullname template (will maintain the release name)
nameOverride: ""

# -- String to fully override fullname template
fullnameOverride: ""

# -- annotations to apply to the pod
podAnnotations: {}

# @ignored
podSecurityContext:
  fsGroup: 65532
  fsGroupChangePolicy: OnRootMismatch
  runAsGroup: 65532
  runAsUser: 65532
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

# @ignored
securityContext:
  allowPrivilegeEscalation: false
  privileged: false
  capabilities:
    drop:
      - ALL
  runAsNonRoot: true
  runAsUser: 65532
  runAsGroup: 65532
  readOnlyRootFilesystem: true
  seccompProfile:
    type: RuntimeDefault

waitForPostgresInitContainer:
  # @ignored
  image:
    registry: docker.io
    repository: library/postgres
    tag: 17.6@sha256:29e0bb09c8e7e7fc265ea9f4367de9622e55bae6b0b97e7cce740c2d63c2ebc0
    pullPolicy: IfNotPresent

service:
  # -- service type
  type: ClusterIP
  # -- port of the FHIR REST endpoint
  port: 8080
  # -- port of the actuator/metrics endpoint
  metricsPort: 8081

ingress:
  # -- if enabled, create an Ingress to expose the FHIR Gateway outside the cluster
  enabled: false
  # -- ingress annotations
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  # -- the ingressClassName
  ingressClassName: ""
  # -- configure the hostname
  hosts:
    - host: chart-example.local
      paths: ["/"]
  # -- TLS config
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# -- set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if primary.resources is set (primary.resources is recommended for production).
# More information: <https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15>
resourcesPreset: "small"
# -- manually set the resource requests and limits
resources: {}
# limits:
#   cpu: 100m
#   memory: 128Mi
# requests:
#   cpu: 100m
#   memory: 128Mi

# -- node labels for pods assignment
# see: <<https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/>>
nodeSelector: {}

# -- tolerations for pods assignment
# see: <https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/>
tolerations: []

# -- affinity for pods assignment
# see: <https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity>
affinity: {}

# -- extra environment vars to set on the FHIR gateway container
extraEnv: []

# @ignored
readinessProbe:
  enabled: true
  httpGet:
    path: /readyz
    port: http
  failureThreshold: 3
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

# @ignored
livenessProbe:
  enabled: true
  httpGet:
    path: /livez
    port: http
  failureThreshold: 3
  initialDelaySeconds: 30
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

metrics:
  serviceMonitor:
    # -- if enabled, creates a ServiceMonitor instance for Prometheus Operator-based monitoring
    enabled: false
    # -- additional labels for the ServiceMonitor resource, e.g. `release: prometheus`
    additionalLabels: {}
    # namespace: monitoring
    # interval: 30s
    # scrapeTimeout: 10s

serviceAccount:
  # -- specifies whether a service account should be created.
  create: false
  # -- annotations to add to the service account
  annotations: {}
  # -- the name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  # -- whether to automount the SA token.
  automountServiceAccountToken: false

sinks:
  postgres:
    # -- if enabled, writes all received FHIR resources to a Postgres DB
    # if `postgres.enabled=true`, then a Postgres DB is started as part of this
    # installation. If `postgres.enabled=false`, then `sinks.postgres.external.*` is used.
    enabled: true
    external:
      # -- host or server name
      host: ""
      # -- port
      port: "5432"
      # -- name of the database to connect to
      database: ""
      # -- username to authenticate as
      username: ""
      # -- password for the user
      password: ""
      # -- can be used to specify the name of an existing secret containing the PostgreSQL password.
      # An alternative to setting the password above.
      existingSecret: ""
      # -- the key inside the `existingSecret` containing the password.
      existingSecretKey: "postgresql-password"
  fhirServer:
    # -- if enabled, sends all received resources to the specified FHIR server
    enabled: false
    # -- URL of the FHIR server. Set basic auth parameters via `extraEnv`
    url: ""

kafka:
  # -- if enabled, the FHIR Gateway is able to use Kafka as input and/or output. Requires the Kafka cluster to be configured using <https://strimzi.io/>
  enabled: false
  # -- either PLAINTEXT or SSL
  securityProtocol: PLAINTEXT
  # -- name of the Strimzi Kafka CRD this gateway should connect to. This is used to resolve the Kafka bootstrap service.
  strimziClusterName: "my-cluster"
  processor:
    # -- if enabled, the FHIR Gateway will read resources from the specified Kafka topics `inputTopics` and write them to dynamic output topics.
    enabled: false
    # -- if enabled, the FHIR Gateway will only read and process resources from the specified Kafka topics `inputTopics` but not write them back to Kafka
    consumeOnly: false
    # -- list of Kafka topics to read FHIR resources from
    inputTopics:
      - fhir-raw
    # -- the Kafka consumer group id. Evaluated as a template.
    groupId: '{{ include "fhir-gateway.fullname" . }}-gateway'
    generateOutputTopics:
      # -- Allows for dynamically generating the Kafka output topic's name based on the input topic.
      # Set to a regular expression which is applied to the input topic and the first match is replaced
      # with the value of `kafka.generateOutputTopics.replaceWith`.
      # You can set this to "^" to add a prefix to the output topic.
      matchExpression: "^"
      # -- value to replace the first regex match with
      replaceMatchWith: "fhir.post-gateway."
  storeFromAPI:
    # -- if enabled, the FHIR Gateway will send resources received from API to the specified Kafka topic `outputTopic`
    # after they are processed
    enabled: false
    # -- the Kafka topic to send API received resources to
    outputTopic: "fhir.post-gateway.api.output"

postgres:
  # -- enabled the included Postgres DB
  # see <https://github.com/CloudPirates-io/helm-charts/tree/main/charts/postgres> for configuration options
  enabled: true
  auth:
    # -- name of the database to create
    database: "fhir_gateway"
    # -- username for the database user
    username: "fhir_gateway_admin"
    # -- disable the default postgres user
    enablePostgresUser: false
  # @ignored
  resources: # +doc-gen:ignore
    requests:
      memory: 128Mi
      cpu: 100m
      ephemeral-storage: 50Mi
    limits:
      memory: 192Mi
      cpu: 150m
      ephemeral-storage: 2Gi

loincConverter:
  # -- whether to enable the LOINC conversion and harmonization service
  enabled: true

  # @ignored
  image:
    registry: ghcr.io
    repository: miracum/loinc-conversion
    tag: v1.15.9@sha256:15b2e9ee38060b46499f0a412634d6f14a850a6a3d57f667bece5bb44f3359b5
    pullPolicy: IfNotPresent

  metrics:
    serviceMonitor:
      # -- if enabled, creates a ServiceMonitor instance for Prometheus Operator-based monitoring
      enabled: false
      # -- additional labels for the ServiceMonitor resource, e.g. `release: prometheus`
      additionalLabels: {}
      # namespace: monitoring
      # interval: 30s
      # scrapeTimeout: 10s

  # -- if necessary, the service can easily scale horizontally
  replicaCount: 1

  # -- credentials to use when pulling the image
  imagePullSecrets: []

  # -- annotations for the pod
  podAnnotations: {}

  # @ignored
  podSecurityContext:
    fsGroup: 65532
    fsGroupChangePolicy: OnRootMismatch
    runAsGroup: 65532
    runAsUser: 65532
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  # @ignored
  securityContext:
    allowPrivilegeEscalation: false
    privileged: false
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    seccompProfile:
      type: RuntimeDefault

  service:
    # -- service type
    type: ClusterIP
    # -- port for the conversion REST endpoint
    port: 8080

  # -- set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if primary.resources is set (primary.resources is recommended for production).
  # More information: <https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15>
  resourcesPreset: "medium"
  # -- configure the resource requests and limits manually
  resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

  # -- node labels for pods assignment
  # see: <<https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/>>
  nodeSelector: {}

  # -- tolerations for pods assignment
  # see: <https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/>
  tolerations: []

  # -- affinity for pods assignment
  # see: <https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity>
  affinity: {}

  # @ignored
  readinessProbe:
    failureThreshold: 3
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5

  # @ignored
  livenessProbe:
    failureThreshold: 3
    initialDelaySeconds: 30
    periodSeconds: 10
    successThreshold: 1
    timeoutSeconds: 5

  # -- extra environment variables to set on the loinc conversion container
  extraEnv: []

fhir-pseudonymizer:
  # -- whether to enable the FHIR Pseudonymizer - a thin, FHIR-native wrapper on top of gPAS, Vfps, or entici
  # with additional options for anonymization.
  # if this is set to false, then the FHIR gateway will not attempt to pseudonymize/anonymize
  # the resources.
  enabled: true
  # @ignored
  service:
    # sets the pseudonymizer's service port to a fixed one here to be able to use the value
    # within the fhir-gateway's templates.
    port: 8080

  # -- set the pseudonymization service backend
  pseudonymizationService: None

  # @ignored
  vfps:
    nameOverride: gateway-vfps
    postgres:
      # overrides the chart's postgres server name to avoid conflicts with the fhir-gateway's postgresql
      nameOverride: "vfps-postgres"

# @ignored
curl:
  image:
    registry: docker.io
    repository: curlimages/curl
    tag: 8.15.0@sha256:4026b29997dc7c823b51c164b71e2b51e0fd95cce4601f78202c513d97da2922

# container security context applied to init containers used by the query, list, and notify modules.
# also used by the Helm test job pods
# @ignored
restrictedContainerSecurityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  privileged: false
  capabilities:
    drop:
      - ALL
  runAsNonRoot: true
  runAsUser: 65534
  runAsGroup: 65534
  seccompProfile:
    type: RuntimeDefault

# @ignored
tests:
  automountServiceAccountToken: false
  # set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if primary.resources is set (primary.resources is recommended for production).
  # More information: <https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15>
  resourcesPreset: "nano"
  # configure the test pods resource requests and limits
  resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

initContainers:
  # -- set container resources according to one common preset (allowed values: none, nano, micro, small, medium, large, xlarge, 2xlarge). This is ignored if primary.resources is set (primary.resources is recommended for production).
  # More information: <https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15>
  resourcesPreset: "nano"
  # -- configure the init containers pods resource requests and limits manually
  resources: {}
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
